const Sylvester={version:"0.1.3",precision:1e-6};export class Vector{constructor(e){this.setElements(e)}dimensions(){return this.elements.length}e(e){return 1>e||e>this.elements.length?null:this.elements[e-1]}modulus(){return Math.sqrt(this.dot(this))}eql(e){let t=this.elements.length;if(e=e.elements||e,t!=e.length)return!1;do{if(Math.abs(this.elements[t-1]-e[t-1])>Sylvester.precision)return!1}while(--t);return!0}dup(){return new Vector(this.elements)}map(e){const t=[];return this.each((n,s)=>{t.push(e(n,s))}),new Vector(t)}each(e){let t=this.elements.length;const n=t;do{const s=n-t;e(this.elements[s],s+1)}while(--t)}toUnitVector(){const e=this.modulus();return 0===e?this.dup():this.map(t=>t/e)}angleFrom(e){const t=e.elements||e;if(this.elements.length!=t.length)return null;let n=0,s=0,i=0;return this.each((e,r)=>{n+=e*t[r-1];s+=e*e;i+=t[r-1]*t[r-1]}),s=Math.sqrt(s),i=Math.sqrt(i),0==s*i?null:(-1>(e=n/(s*i))&&(e=-1),e>1&&(e=1),Math.acos(e))}isParallelTo(e){return e=this.angleFrom(e),null===e?null:e<=Sylvester.precision}isAntiparallelTo(e){return e=this.angleFrom(e),null===e?null:Math.abs(e-Math.PI)<=Sylvester.precision}isPerpendicularTo(e){return e=this.dot(e),null===e?null:Math.abs(e)<=Sylvester.precision}add(e){const t=e.elements||e;return this.elements.length!=t.length?null:this.map((e,n)=>e+t[n-1])}subtract(e){const t=e.elements||e;return this.elements.length!=t.length?null:this.map((e,n)=>e-t[n-1])}multiply(e){return this.map(t=>t*e)}x(e){return this.multiply(e)}dot(e){e=e.elements||e;let t=0,n=this.elements.length;if(n!=e.length)return null;do{t+=this.elements[n-1]*e[n-1]}while(--n);return t}cross(e){if(e=e.elements||e,3!=this.elements.length||3!=e.length)return null;const t=this.elements;return new Vector([t[1]*e[2]-t[2]*e[1],t[2]*e[0]-t[0]*e[2],t[0]*e[1]-t[1]*e[0]])}max(){let e=0,t=this.elements.length;const n=t;do{const s=n-t;Math.abs(this.elements[s])>Math.abs(e)&&(e=this.elements[s])}while(--t);return e}indexOf(e){let t=null,n=this.elements.length;const s=n;do{const i=s-n;null===t&&this.elements[i]==e&&(t=i+1)}while(--n);return t}toDiagonalMatrix(){return Matrix.Diagonal(this.elements)}round(){return this.map(e=>Math.round(e))}snapTo(e){return this.map(t=>Math.abs(t-e)>Sylvester.precision?t:e)}distanceFrom(e){if(e.anchor)return e.distanceFrom(this);const t=e.elements||e;if(t.length!=this.elements.length)return null;let n,s=0;return this.each((e,i)=>{n=e-t[i-1];s+=n*n}),Math.sqrt(s)}liesOn(e){return e.contains(this)}liesIn(e){return e.contains(this)}rotate(e,t){switch(this.elements.length){case 2:let n=t.elements||t;if(2!=n.length)return null;let s=Matrix.Rotation(e).elements,i=this.elements[0]-n[0],r=this.elements[1]-n[1];return new Vector([n[0]+s[0][0]*i+s[0][1]*r,n[1]+s[1][0]*i+s[1][1]*r]);case 3:if(!t.direction)return null;const l=t.pointClosestTo(this).elements;return s=Matrix.Rotation(e,t.direction).elements,i=this.elements[0]-l[0],r=this.elements[1]-l[1],n=this.elements[2]-l[2],new Vector([l[0]+s[0][0]*i+s[0][1]*r+s[0][2]*n,l[1]+s[1][0]*i+s[1][1]*r+s[1][2]*n,l[2]+s[2][0]*i+s[2][1]*r+s[2][2]*n]);default:return null}}reflectionIn(e){if(e.anchor){const t=[...this.elements];return e=e.pointClosestTo(t).elements,new Vector([e[0]+(e[0]-t[0]),e[1]+(e[1]-t[1]),e[2]+(e[2]-(t[2]||0))])}const t=e.elements||e;return this.elements.length!=t.length?null:this.map((e,n)=>t[n-1]+(t[n-1]-e))}to3D(){const e=this.dup();switch(e.elements.length){case 3:break;case 2:e.elements.push(0);break;default:return null}return e}inspect(){return`[${this.elements.join(", ")}]`}setElements(e){return this.elements=[...e.elements||e],this}static create(e){return new Vector(e)}static Random(e){const t=[];do{t.push(Math.random())}while(--e);return new Vector(t)}static Zero(e){const t=[];do{t.push(0)}while(--e);return new Vector(t)}};Vector.i=new Vector([1,0,0]),Vector.j=new Vector([0,1,0]),Vector.k=new Vector([0,0,1]);export class Matrix{constructor(e){this.setElements(e)}e(e,t){return 1>e||e>this.elements.length||1>t||t>this.elements[0].length?null:this.elements[e-1][t-1]}row(e){return e>this.elements.length?null:new Vector(this.elements[e-1])}col(e){if(e>this.elements[0].length)return null;const t=[];let n=this.elements.length;const s=n;do{const i=s-n;t.push(this.elements[i][e-1])}while(--n);return new Vector(t)}dimensions(){return{rows:this.elements.length,cols:this.elements[0].length}}rows(){return this.elements.length}cols(){return this.elements[0].length}eql(e){if(void 0===(e=e.elements||e)[0][0]&&(e=new Matrix(e).elements),this.elements.length!=e.length||this.elements[0].length!=e[0].length)return!1;let t=this.elements.length;const n=t,s=this.elements[0].length;do{const i=n-t;let r=s;do{const t=s-r;if(Math.abs(this.elements[i][t]-e[i][t])>Sylvester.precision)return!1}while(--r)}while(--t);return!0}dup(){return new Matrix(this.elements)}map(e){const t=[];let n=this.elements.length;const s=n,i=this.elements[0].length;do{const r=s-n;let l=i;t[r]=[];do{const n=i-l;t[r][n]=e(this.elements[r][n],r+1,n+1)}while(--l)}while(--n);return new Matrix(t)}isSameSizeAs(e){return void 0===(e=e.elements||e)[0][0]&&(e=new Matrix(e).elements),this.elements.length==e.length&&this.elements[0].length==e[0].length}add(e){let t=e.elements||e;return void 0===t[0][0]&&(t=new Matrix(t).elements),this.isSameSizeAs(t)?this.map((e,n,s)=>e+t[n-1][s-1]):null}subtract(e){let t=e.elements||e;return void 0===t[0][0]&&(t=new Matrix(t).elements),this.isSameSizeAs(t)?this.map((e,n,s)=>e-t[n-1][s-1]):null}canMultiplyFromLeft(e){return void 0===(e=e.elements||e)[0][0]&&(e=new Matrix(e).elements),this.elements[0].length==e.length}multiply(e){if(!e.elements)return this.map(t=>t*e);const t=!!e.modulus;let n=e.elements||e;if(void 0===n[0][0]&&(n=new Matrix(n).elements),!this.canMultiplyFromLeft(n))return null;let s=this.elements.length;const i=s,r=n[0].length,l=this.elements[0].length,o=[];do{const e=i-s;o[e]=[];let t=r;do{const s=r-t;let i=0,h=l;do{const t=l-h;i+=this.elements[e][t]*n[t][s]}while(--h);o[e][s]=i}while(--t)}while(--s);return n=new Matrix(o),t?n.col(1):n}x(e){return this.multiply(e)}minor(e,t,n,s){const i=[];let r=n;const l=this.elements.length,o=this.elements[0].length;do{const h=n-r;i[h]=[];let c=s;do{const n=s-c;i[h][n]=this.elements[(e+h-1)%l][(t+n-1)%o]}while(--c)}while(--r);return new Matrix(i)}transpose(){const e=this.elements.length,t=this.elements[0].length,n=[];let s=t;do{const i=t-s;n[i]=[];let r=e;do{const t=e-r;n[i][t]=this.elements[t][i]}while(--r)}while(--s);return new Matrix(n)}isSquare(){return this.elements.length==this.elements[0].length}max(){let e=0,t=this.elements.length;const n=t,s=this.elements[0].length;do{const i=n-t;let r=s;do{const t=s-r;Math.abs(this.elements[i][t])>Math.abs(e)&&(e=this.elements[i][t])}while(--r)}while(--t);return e}indexOf(e){let t=this.elements.length;const n=t,s=this.elements[0].length;do{const i=n-t;let r=s;do{const t=s-r;if(this.elements[i][t]==e)return{i:i+1,j:t+1}}while(--r)}while(--t);return null}diagonal(){if(!this.isSquare)return null;const e=[];let t=this.elements.length;const n=t;do{const s=n-t;e.push(this.elements[s][s])}while(--t);return new Vector(e)}toRightTriangular(){const e=this.dup();let t=this.elements.length;const n=t,s=this.elements[0].length;do{const o=n-t;if(0==e.elements[o][o])for(j=o+1;j<n;j++)if(0!=e.elements[j][o]){var i=[],r=s;do{var l=s-r;i.push(e.elements[o][l]+e.elements[j][l])}while(--r);e.elements[o]=i;break}if(0!=e.elements[o][o])for(j=o+1;j<n;j++){const t=e.elements[j][o]/e.elements[o][o];i=[],r=s;do{l=s-r,i.push(l>o?e.elements[j][l]-e.elements[o][l]*t:0)}while(--r);e.elements[j]=i}}while(--t);return e}toUpperTriangular(){return this.toRightTriangular()}determinant(){if(!this.isSquare())return null;const e=this.toRightTriangular();let t=e.elements[0][0],n=e.elements.length-1;const s=n;do{const i=s-n+1;t*=e.elements[i][i]}while(--n);return t}det(){return this.determinant()}isSingular(){return this.isSquare()&&0===this.determinant()}trace(){if(!this.isSquare())return null;let e=this.elements[0][0],t=this.elements.length-1;const n=t;do{const s=n-t+1;e+=this.elements[s][s]}while(--t);return e}tr(){return this.trace()}rank(){const e=this.toRightTriangular();let t=0,n=this.elements.length;const s=n,i=this.elements[0].length;do{const r=s-n;let l=i;do{const n=i-l;if(Math.abs(e.elements[r][n])>Sylvester.precision){t++;break}}while(--l)}while(--n);return t}rk(){return this.rank()}augment(e){void 0===(e=e.elements||e)[0][0]&&(e=new Matrix(e).elements);const t=this.dup(),n=t.elements[0].length;let s=t.elements.length;const i=s,r=e[0].length;if(s!=e.length)return null;do{const l=i-s;let o=r;do{const s=r-o;t.elements[l][n+s]=e[l][s]}while(--o)}while(--s);return t}inverse(){if(!this.isSquare()||this.isSingular())return null;let e=this.elements.length;const t=e,n=this.augment(Matrix.I(e)).toRightTriangular(),s=n.elements[0].length,i=[];do{const l=e-1;let o=[],h=s;i[l]=[];let c=n.elements[l][l];do{var r=s-h;const e=n.elements[l][r]/c;o.push(e),r>=t&&i[l].push(e)}while(--h);for(n.elements[l]=o,c=0;l>c;c++){o=[],h=s;do{r=s-h,o.push(n.elements[c][r]-n.elements[l][r]*n.elements[c][l])}while(--h);n.elements[c]=o}}while(--e);return new Matrix(i)}inv(){return this.inverse()}round(){return this.map(e=>Math.round(e))}snapTo(e){return this.map(t=>Math.abs(t-e)>Sylvester.precision?t:e)}inspect(){const e=[];let t=this.elements.length;const n=t;do{const s=n-t;e.push(new Vector(this.elements[s]).inspect())}while(--t);return e.join("\n")}setElements(e){const t=e.elements||e;if(void 0!==t[0][0]){var n=t.length,s=n;let i;this.elements=[];do{const r=i=t[e=s-n].length;this.elements[e]=[];do{const n=r-i;this.elements[e][n]=t[e][n]}while(--i)}while(--n);return this}s=n=t.length,this.elements=[];do{e=s-n,this.elements.push([t[e]])}while(--n);return this}static create(e){return new Matrix(e)}static I(e){const t=[],n=e;do{const s=n-e;t[s]=[];let i=n;do{const e=n-i;t[s][e]=s==e?1:0}while(--i)}while(--e);return new Matrix(t)}static Diagonal(e){let t=e.length;const n=t,s=Matrix.I(t);do{const i=n-t;s.elements[i][i]=e[i]}while(--t);return s}static Rotation(e,t){if(!t)return new Matrix([[Math.cos(e),-Math.sin(e)],[Math.sin(e),Math.cos(e)]]);let n=t.dup();if(3!=n.elements.length)return null;let s=n.modulus();const i=n.elements[0]/s,r=n.elements[1]/s;n=n.elements[2]/s,s=Math.sin(e);const l=Math.cos(e),o=1-l;return new Matrix([[o*i*i+l,o*i*r-s*n,o*i*n+s*r],[o*i*r+s*n,o*r*r+l,o*r*n-s*i],[o*i*n-s*r,o*r*n+s*i,o*n*n+l]])}static RotationX(e){const t=Math.cos(e);return e=Math.sin(e),new Matrix([[1,0,0],[0,t,-e],[0,e,t]])}static RotationY(e){const t=Math.cos(e);return e=Math.sin(e),new Matrix([[t,0,e],[0,1,0],[-e,0,t]])}static RotationZ(e){const t=Math.cos(e);return e=Math.sin(e),new Matrix([[t,-e,0],[e,t,0],[0,0,1]])}static Random(e,t){return Matrix.Zero(e,t).map(()=>Math.random())}static Zero(e,t){const n=[];let s=e;do{const i=e-s;n[i]=[];let r=t;do{const e=t-r;n[i][e]=0}while(--r)}while(--s);return new Matrix(n)}};export class Line{constructor(e,t){this.setVectors(e,t)}eql(e){return this.isParallelTo(e)&&this.contains(e.anchor)}dup(){return new Line(this.anchor,this.direction)}translate(e){return e=e.elements||e,new Line([this.anchor.elements[0]+e[0],this.anchor.elements[1]+e[1],this.anchor.elements[2]+(e[2]||0)],this.direction)}isParallelTo(e){return e.normal?e.isParallelTo(this):(e=this.direction.angleFrom(e.direction),Math.abs(e)<=Sylvester.precision||Math.abs(e-Math.PI)<=Sylvester.precision)}distanceFrom(e){if(e.normal)return e.distanceFrom(this);if(e.direction){if(this.isParallelTo(e))return this.distanceFrom(e.anchor);var t=this.direction.cross(e.direction).toUnitVector().elements,n=this.anchor.elements;return e=e.anchor.elements,Math.abs((n[0]-e[0])*t[0]+(n[1]-e[1])*t[1]+(n[2]-e[2])*t[2])}let s=e.elements||e;n=this.anchor.elements,t=this.direction.elements,e=s[0]-n[0];const i=s[1]-n[1];return s=(s[2]||0)-n[2],0===(n=Math.sqrt(e*e+i*i+s*s))?0:(t=(e*t[0]+i*t[1]+s*t[2])/n,t=1-t*t,Math.abs(n*Math.sqrt(0>t?0:t)))}contains(e){return null!==(e=this.distanceFrom(e))&&e<=Sylvester.precision}liesIn(e){return e.contains(this)}intersects(e){return e.normal?e.intersects(this):!this.isParallelTo(e)&&this.distanceFrom(e)<=Sylvester.precision}intersectionWith(e){if(e.normal)return e.intersectionWith(this);if(!this.intersects(e))return null;const t=this.anchor.elements;let n=this.direction.elements,s=e.anchor.elements,i=e.direction.elements;e=n[0];const r=n[1];n=n[2];let l=i[0];const o=i[1];i=i[2];const h=t[0]-s[0],c=t[1]-s[1],u=l*l+o*o+i*i,m=e*l+r*o+n*i;return l=((-e*h-r*c-n*(s=t[2]-s[2]))*u/(e*e+r*r+n*n)+m*(l*h+o*c+i*s))/(u-m*m),new Vector([t[0]+l*e,t[1]+l*r,t[2]+l*n])}pointClosestTo(e){if(e.direction){if(this.intersects(e))return this.intersectionWith(e);if(this.isParallelTo(e))return null;var t=this.direction.elements,n=e.direction.elements,s=t[0],i=t[1];t=t[2];var r=n[0],l=n[1];const c=n[2];var o=s*l-i*r,h=i*c-t*l;return s=new Vector([(n=t*r-s*c)*c-o*l,o*r-h*c,h*l-n*r]),(e=new Plane(e.anchor,s)).intersectionWith(this)}return e=e.elements||e,this.contains(e)?new Vector(e):(n=this.anchor.elements,t=this.direction.elements,s=t[0],i=t[1],t=t[2],r=n[0],o=n[1],l=n[2],n=s*(e[1]-o)-i*(e[0]-r),o=i*((e[2]||0)-l)-t*(e[1]-o),h=t*(e[0]-r)-s*((e[2]||0)-l),s=new Vector([i*n-t*h,t*o-s*n,s*h-i*o]),i=this.distanceFrom(e)/s.modulus(),new Vector([e[0]+s.elements[0]*i,e[1]+s.elements[1]*i,(e[2]||0)+s.elements[2]*i]))}rotate(e,t){void 0===t.direction&&(t=new Line(t.to3D(),Vector.k));const n=Matrix.Rotation(e,t.direction).elements;let s=t.pointClosestTo(this.anchor).elements,i=this.anchor.elements;const r=this.direction.elements,l=s[0],o=s[1];s=s[2];const h=i[0]-l,c=i[1]-o;return i=i[2]-s,new Line([l+n[0][0]*h+n[0][1]*c+n[0][2]*i,o+n[1][0]*h+n[1][1]*c+n[1][2]*i,s+n[2][0]*h+n[2][1]*c+n[2][2]*i],[n[0][0]*r[0]+n[0][1]*r[1]+n[0][2]*r[2],n[1][0]*r[0]+n[1][1]*r[1]+n[1][2]*r[2],n[2][0]*r[0]+n[2][1]*r[1]+n[2][2]*r[2]])}reflectionIn(e){if(e.normal){let t=this.anchor.elements,n=this.direction.elements,s=t[0],i=t[1];t=t[2];const r=n[0],l=n[1],o=n[2];return n=this.anchor.reflectionIn(e).elements,s+=r,i+=l,t+=o,e=e.pointClosestTo([s,i,t]).elements,new Line(n,[e[0]+(e[0]-s)-n[0],e[1]+(e[1]-i)-n[1],e[2]+(e[2]-t)-n[2]])}return e.direction?this.rotate(Math.PI,e):(e=e.elements||e,new Line(this.anchor.reflectionIn([e[0],e[1],e[2]||0]),this.direction))}setVectors(e,t){if(e=new Vector(e),t=new Vector(t),2==e.elements.length&&e.elements.push(0),2==t.elements.length&&t.elements.push(0),e.elements.length>3||t.elements.length>3)return null;const n=t.modulus();return 0===n?null:(this.anchor=e,this.direction=new Vector([t.elements[0]/n,t.elements[1]/n,t.elements[2]/n]),this)}static create(e,t){return(new Line).setVectors(e,t)}};Line.X=new Line(Vector.Zero(3),Vector.i),Line.Y=new Line(Vector.Zero(3),Vector.j),Line.Z=new Line(Vector.Zero(3),Vector.k);export class Plane{constructor(e,t,n){this.setVectors(e,t,n)}eql(e){return this.contains(e.anchor)&&this.isParallelTo(e)}dup(){return new Plane(this.anchor,this.normal)}translate(e){return e=e.elements||e,new Plane([this.anchor.elements[0]+e[0],this.anchor.elements[1]+e[1],this.anchor.elements[2]+(e[2]||0)],this.normal)}isParallelTo(e){return e.normal?(e=this.normal.angleFrom(e.normal),Math.abs(e)<=Sylvester.precision||Math.abs(Math.PI-e)<=Sylvester.precision):e.direction?this.normal.isPerpendicularTo(e.direction):null}isPerpendicularTo(e){return e=this.normal.angleFrom(e.normal),Math.abs(Math.PI/2-e)<=Sylvester.precision}distanceFrom(e){if(this.intersects(e)||this.contains(e))return 0;if(e.anchor){var t=this.anchor.elements,n=e.anchor.elements;return e=this.normal.elements,Math.abs((t[0]-n[0])*e[0]+(t[1]-n[1])*e[1]+(t[2]-n[2])*e[2])}return n=e.elements||e,t=this.anchor.elements,e=this.normal.elements,Math.abs((t[0]-n[0])*e[0]+(t[1]-n[1])*e[1]+(t[2]-(n[2]||0))*e[2])}contains(e){if(e.normal)return null;if(e.direction)return this.contains(e.anchor)&&this.contains(e.anchor.add(e.direction));e=e.elements||e;const t=this.anchor.elements,n=this.normal.elements;return Math.abs(n[0]*(t[0]-e[0])+n[1]*(t[1]-e[1])+n[2]*(t[2]-(e[2]||0)))<=Sylvester.precision}intersects(e){return void 0===e.direction&&void 0===e.normal?null:!this.isParallelTo(e)}intersectionWith(e){if(!this.intersects(e))return null;if(e.direction){var t=e.anchor.elements,n=e.direction.elements;e=this.anchor.elements;var s=this.normal.elements;return e=(s[0]*(e[0]-t[0])+s[1]*(e[1]-t[1])+s[2]*(e[2]-t[2]))/(s[0]*n[0]+s[1]*n[1]+s[2]*n[2]),new Vector([t[0]+n[0]*e,t[1]+n[1]*e,t[2]+n[2]*e])}if(e.normal){n=this.normal.cross(e.normal).toUnitVector(),s=this.normal.elements,t=this.anchor.elements;let i=e.normal.elements;const r=e.anchor.elements;let l=Matrix.Zero(2,2);for(e=0;l.isSingular();)l=new Matrix([[s[++e%3],s[(e+1)%3]],[i[e%3],i[(e+1)%3]]]);for(l=l.inverse().elements,t=s[0]*t[0]+s[1]*t[1]+s[2]*t[2],s=i[0]*r[0]+i[1]*r[1]+i[2]*r[2],t=[l[0][0]*t+l[0][1]*s,l[1][0]*t+l[1][1]*s],s=[],i=1;3>=i;i++)s.push(e==i?0:t[(i+(5-e)%3)%3]);return new Line(s,n)}}pointClosestTo(e){e=e.elements||e;let t=this.anchor.elements;const n=this.normal.elements;return t=(t[0]-e[0])*n[0]+(t[1]-e[1])*n[1]+(t[2]-(e[2]||0))*n[2],new Vector([e[0]+n[0]*t,e[1]+n[1]*t,(e[2]||0)+n[2]*t])}rotate(e,t){const n=Matrix.Rotation(e,t.direction).elements;let s=t.pointClosestTo(this.anchor).elements,i=this.anchor.elements;const r=this.normal.elements,l=s[0],o=s[1];s=s[2];const h=i[0]-l,c=i[1]-o;return i=i[2]-s,new Plane([l+n[0][0]*h+n[0][1]*c+n[0][2]*i,o+n[1][0]*h+n[1][1]*c+n[1][2]*i,s+n[2][0]*h+n[2][1]*c+n[2][2]*i],[n[0][0]*r[0]+n[0][1]*r[1]+n[0][2]*r[2],n[1][0]*r[0]+n[1][1]*r[1]+n[1][2]*r[2],n[2][0]*r[0]+n[2][1]*r[1]+n[2][2]*r[2]])}reflectionIn(e){if(e.normal){let t=this.anchor.elements,n=this.normal.elements,s=t[0],i=t[1];t=t[2];const r=n[0],l=n[1],o=n[2];return n=this.anchor.reflectionIn(e).elements,s+=r,i+=l,t+=o,e=e.pointClosestTo([s,i,t]).elements,new Plane(n,[e[0]+(e[0]-s)-n[0],e[1]+(e[1]-i)-n[1],e[2]+(e[2]-t)-n[2]])}return e.direction?this.rotate(Math.PI,e):(e=e.elements||e,new Plane(this.anchor.reflectionIn([e[0],e[1],e[2]||0]),this.normal))}setVectors(e,t,n){if(e=new Vector(e),null===(e=e.to3D()))return null;if(t=new Vector(t),null===(t=t.to3D()))return null;if(void 0===n)n=null;else if(n=new Vector(n),null===(n=n.to3D()))return null;let s=e.elements[0],i=e.elements[1];const r=e.elements[2],l=t.elements[0],o=t.elements[1],h=t.elements[2];if(null!==n){t=n.elements[0];const e=n.elements[1];if(n=n.elements[2],i=new Vector([(o-i)*(n-r)-(h-r)*(e-i),(h-r)*(t-s)-(l-s)*(n-r),(l-s)*(e-i)-(o-i)*(t-s)]),0===(s=i.modulus()))return null;i=new Vector([i.elements[0]/s,i.elements[1]/s,i.elements[2]/s])}else{if(0===(s=Math.sqrt(l*l+o*o+h*h)))return null;i=new Vector([t.elements[0]/s,t.elements[1]/s,t.elements[2]/s])}return this.anchor=e,this.normal=i,this}static create(e,t,n){return new Plane(e,t,n)}};Plane.XY=new Plane(Vector.Zero(3),Vector.k),Plane.YZ=new Plane(Vector.Zero(3),Vector.i),Plane.ZX=new Plane(Vector.Zero(3),Vector.j),Plane.YX=Plane.XY,Plane.ZY=Plane.YZ,Plane.XZ=Plane.ZX;export const $V=Vector.create;export const $M=Matrix.create;export const $L=Line.create;export const $P=Plane.create;